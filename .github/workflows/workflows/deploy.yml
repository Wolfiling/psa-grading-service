# ===============================================
# GITHUB ACTIONS - PSA GRADING APP DEPLOYMENT
# ===============================================
# 🚀 Pipeline CI/CD complet avec Docker et déploiement automatisé
# 🔒 Gestion sécurisée des secrets GitHub
# 📊 Tests, build, déploiement, rollback automatique

name: '🚀 PSA Grading App - Deploy'

on:
  push:
    branches: [ main, develop ]
    paths-ignore:
      - '*.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      skip_tests:
        description: 'Skip tests'
        required: false
        default: false
        type: boolean

# ===============================================
# VARIABLES GLOBALES
# ===============================================
env:
  # Configuration Docker
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  
  # Configuration Node.js
  NODE_VERSION: '18'
  
  # Configuration déploiement
  DEPLOYMENT_TIMEOUT: 900  # 15 minutes
  HEALTH_CHECK_RETRIES: 10
  HEALTH_CHECK_INTERVAL: 30

# ===============================================
# JOBS PIPELINE
# ===============================================
jobs:
  # ===============================================
  # 🔍 ANALYSE ET VALIDATION
  # ===============================================
  analyze:
    name: '🔍 Code Analysis & Security'
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event_name == 'push'
    
    outputs:
      should-deploy: ${{ steps.changes.outputs.should-deploy }}
      environment: ${{ steps.env-detection.outputs.environment }}
      
    steps:
      - name: '📥 Checkout Code'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: '🔍 Detect Changes'
        id: changes
        run: |
          # Vérifier si des fichiers critiques ont changé
          if git diff --name-only ${{ github.event.before }}..${{ github.sha }} | grep -E "(server/|client/|package\.json|Dockerfile)" > /dev/null; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          fi
          
      - name: '🎯 Environment Detection'
        id: env-detection
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
          else
            echo "environment=review" >> $GITHUB_OUTPUT
          fi
          
      - name: '🔒 Security Scan - CodeQL'
        if: github.event_name == 'pull_request'
        uses: github/codeql-action/init@v3
        with:
          languages: javascript
          
      - name: '🔒 Security Scan - Trivy'
        if: steps.changes.outputs.should-deploy == 'true'
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          
      - name: '📤 Upload Security Results'
        if: steps.changes.outputs.should-deploy == 'true'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'

  # ===============================================
  # 🧪 TESTS ET VALIDATION
  # ===============================================
  test:
    name: '🧪 Tests & Quality'
    runs-on: ubuntu-latest
    needs: analyze
    if: needs.analyze.outputs.should-deploy == 'true' && !github.event.inputs.skip_tests
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_USER: test_user
          POSTGRES_DB: psa_grading_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    strategy:
      matrix:
        node-version: ['18', '20']
        
    steps:
      - name: '📥 Checkout Code'
        uses: actions/checkout@v4
        
      - name: '🟢 Setup Node.js ${{ matrix.node-version }}'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
          
      - name: '📦 Install Dependencies'
        run: |
          npm ci --prefer-offline --no-audit
          
      - name: '🔧 Setup Test Environment'
        run: |
          cp .env.github.template .env.test
          echo "DATABASE_URL=postgresql://test_user:test_password@localhost:5432/psa_grading_test" >> .env.test
          echo "NODE_ENV=test" >> .env.test
          
      - name: '🗃️ Database Setup'
        run: |
          NODE_ENV=test npm run db:migrate || true
          
      - name: '🧪 Run Tests'
        run: |
          npm run test:coverage
        env:
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/psa_grading_test
          NODE_ENV: test
          
      - name: '🔍 ESLint Check'
        run: |
          npx eslint . --ext .js,.jsx --max-warnings 0 || true
          
      - name: '🛡️ Security Validation'
        run: |
          npm run security:validate || true
          
      - name: '📊 Upload Coverage'
        if: matrix.node-version == '18'
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
          fail_ci_if_error: false

  # ===============================================
  # 🐳 BUILD DOCKER IMAGE
  # ===============================================
  build:
    name: '🐳 Docker Build & Push'
    runs-on: ubuntu-latest
    needs: [analyze, test]
    if: |
      always() && 
      needs.analyze.outputs.should-deploy == 'true' && 
      (needs.test.result == 'success' || needs.test.result == 'skipped')
      
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      
    steps:
      - name: '📥 Checkout Code'
        uses: actions/checkout@v4
        
      - name: '🐳 Setup Docker Buildx'
        uses: docker/setup-buildx-action@v3
        
      - name: '🔐 Login to Container Registry'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: '🏷️ Extract Metadata'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            
      - name: '🔨 Build and Push Image'
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
            
      - name: '🔍 Scan Docker Image'
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.meta.outputs.tags }}
          format: 'sarif'
          output: 'docker-trivy-results.sarif'
          
      - name: '📤 Upload Docker Scan Results'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'docker-trivy-results.sarif'

  # ===============================================
  # 🚀 DÉPLOIEMENT STAGING
  # ===============================================
  deploy-staging:
    name: '🚀 Deploy to Staging'
    runs-on: ubuntu-latest
    needs: [analyze, test, build]
    if: |
      always() && 
      needs.analyze.outputs.environment == 'staging' &&
      needs.build.result == 'success'
      
    environment:
      name: staging
      url: https://staging.${{ secrets.DOMAIN }}
      
    steps:
      - name: '📥 Checkout Code'
        uses: actions/checkout@v4
        
      - name: '🔧 Setup Deployment Environment'
        run: |
          echo "DEPLOYMENT_ENV=staging" >> $GITHUB_ENV
          echo "DOCKER_IMAGE=${{ needs.build.outputs.image-tag }}" >> $GITHUB_ENV
          
      - name: '🚀 Deploy to Staging Server'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          port: ${{ secrets.STAGING_PORT || 22 }}
          timeout: ${{ env.DEPLOYMENT_TIMEOUT }}
          script: |
            set -e
            
            # Variables
            export DOCKER_IMAGE="${{ needs.build.outputs.image-tag }}"
            export DEPLOYMENT_ENV="staging"
            export APP_DIR="/var/www/psa-grading-app"
            export COMPOSE_FILE="$APP_DIR/docker-compose.staging.yml"
            
            # Navigation
            cd $APP_DIR
            
            # Backup avant déploiement
            docker-compose -f $COMPOSE_FILE exec -T postgres pg_dump -U postgres psa_grading > backup-staging-$(date +%Y%m%d-%H%M%S).sql || true
            
            # Pull nouvelle image
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            docker pull $DOCKER_IMAGE
            
            # Mise à jour configuration
            export DATABASE_URL="${{ secrets.STAGING_DATABASE_URL }}"
            export BREVO_API_KEY="${{ secrets.BREVO_API_KEY }}"
            export PSA_EMAIL="${{ secrets.PSA_EMAIL }}"
            export PSA_PASSWORD="${{ secrets.PSA_PASSWORD }}"
            export ADMIN_PASSWORD="${{ secrets.STAGING_ADMIN_PASSWORD }}"
            export SESSION_SECRET="${{ secrets.SESSION_SECRET }}"
            export PSA_SECRET="${{ secrets.PSA_SECRET }}"
            export JWT_SECRET="${{ secrets.JWT_SECRET }}"
            export PSA_CLIENT_SECRET="${{ secrets.PSA_CLIENT_SECRET }}"
            
            # Déploiement sans downtime
            docker-compose -f $COMPOSE_FILE up -d --remove-orphans
            
            # Health check
            for i in {1..10}; do
              if curl -f -s "http://localhost:5000/healthz" > /dev/null; then
                echo "✅ Staging deployment successful!"
                break
              fi
              echo "⏳ Waiting for application (attempt $i/10)..."
              sleep 30
            done
            
      - name: '🔍 Post-deployment Tests'
        run: |
          # Tests post-déploiement
          sleep 60
          curl -f "https://staging.${{ secrets.DOMAIN }}/healthz" || exit 1
          echo "✅ Staging health check passed"
          
      - name: '📧 Notify Deployment'
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,commit,author,action,eventName,ref,workflow

  # ===============================================
  # 🏭 DÉPLOIEMENT PRODUCTION  
  # ===============================================
  deploy-production:
    name: '🏭 Deploy to Production'
    runs-on: ubuntu-latest
    needs: [analyze, test, build]
    if: |
      always() && 
      needs.analyze.outputs.environment == 'production' &&
      needs.build.result == 'success'
      
    environment:
      name: production
      url: https://${{ secrets.DOMAIN }}
      
    steps:
      - name: '📥 Checkout Code'
        uses: actions/checkout@v4
        
      - name: '⏸️ Manual Approval Required'
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ secrets.GITHUB_TOKEN }}
          approvers: ${{ secrets.PRODUCTION_APPROVERS }}
          minimum-approvals: 2
          issue-title: "🏭 Production Deployment Approval - ${{ github.sha }}"
          issue-body: |
            **Production deployment requires approval**
            
            **Changes:**
            - Commit: ${{ github.sha }}
            - Author: ${{ github.actor }}
            - Branch: ${{ github.ref }}
            
            **Docker Image:**
            - Image: ${{ needs.build.outputs.image-tag }}
            - Digest: ${{ needs.build.outputs.image-digest }}
            
            **Pre-deployment Checklist:**
            - [ ] All tests passed
            - [ ] Security scans completed
            - [ ] Staging deployment successful
            - [ ] Database migrations reviewed
            - [ ] Rollback plan confirmed
            
            Please review and approve this deployment.
            
      - name: '💾 Create Production Backup'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          port: ${{ secrets.PRODUCTION_PORT || 22 }}
          timeout: 300
          script: |
            set -e
            
            # Backup complet avant déploiement
            export BACKUP_DIR="/var/backups/psa-grading"
            export TIMESTAMP=$(date +%Y%m%d-%H%M%S)
            
            mkdir -p $BACKUP_DIR
            
            # Backup base de données
            docker exec psa-postgres pg_dump -U postgres psa_grading > $BACKUP_DIR/db-backup-$TIMESTAMP.sql
            
            # Backup application
            tar -czf $BACKUP_DIR/app-backup-$TIMESTAMP.tar.gz -C /var/www psa-grading-app
            
            # Backup configuration
            cp /var/www/psa-grading-app/.env $BACKUP_DIR/env-backup-$TIMESTAMP
            
            echo "✅ Backup completed: $BACKUP_DIR/backup-$TIMESTAMP"
            
      - name: '🚀 Deploy to Production'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          port: ${{ secrets.PRODUCTION_PORT || 22 }}
          timeout: ${{ env.DEPLOYMENT_TIMEOUT }}
          script: |
            set -e
            
            # Variables production
            export DOCKER_IMAGE="${{ needs.build.outputs.image-tag }}"
            export DEPLOYMENT_ENV="production"
            export APP_DIR="/var/www/psa-grading-app"
            export COMPOSE_FILE="$APP_DIR/docker-compose.production.yml"
            
            cd $APP_DIR
            
            # Login Docker
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Pull nouvelle image
            docker pull $DOCKER_IMAGE
            
            # Configuration production
            export DATABASE_URL="${{ secrets.PRODUCTION_DATABASE_URL }}"
            export BREVO_API_KEY="${{ secrets.BREVO_API_KEY }}"
            export PSA_EMAIL="${{ secrets.PSA_EMAIL }}"
            export PSA_PASSWORD="${{ secrets.PSA_PASSWORD }}"
            export ADMIN_PASSWORD="${{ secrets.PRODUCTION_ADMIN_PASSWORD }}"
            export SESSION_SECRET="${{ secrets.SESSION_SECRET }}"
            export PSA_SECRET="${{ secrets.PSA_SECRET }}"
            export JWT_SECRET="${{ secrets.JWT_SECRET }}"
            export PSA_CLIENT_SECRET="${{ secrets.PSA_CLIENT_SECRET }}"
            export ALLOWED_ORIGINS="https://${{ secrets.DOMAIN }}"
            export PUBLIC_URL="https://${{ secrets.DOMAIN }}"
            
            # Déploiement blue-green
            docker-compose -f $COMPOSE_FILE up -d --remove-orphans --scale app=2
            
            # Attente stabilisation
            sleep 60
            
            # Health check approfondi
            for i in {1..${{ env.HEALTH_CHECK_RETRIES }}}; do
              if curl -f -s "http://localhost:5000/healthz" > /dev/null; then
                echo "✅ Production health check passed (attempt $i)"
                break
              fi
              echo "⏳ Production health check (attempt $i/${{ env.HEALTH_CHECK_RETRIES }})..."
              sleep ${{ env.HEALTH_CHECK_INTERVAL }}
              
              if [ $i -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
                echo "❌ Production health check failed - initiating rollback"
                exit 1
              fi
            done
            
            # Validation fonctionnelle
            curl -f "https://${{ secrets.DOMAIN }}/healthz" || exit 1
            
            # Nettoyage anciennes images
            docker image prune -f --filter "until=24h"
            
      - name: '✅ Production Deployment Success'
        run: |
          echo "🎉 Production deployment completed successfully!"
          echo "🌐 Application URL: https://${{ secrets.DOMAIN }}"
          echo "📊 Commit: ${{ github.sha }}"
          echo "🐳 Image: ${{ needs.build.outputs.image-tag }}"
          
      - name: '📧 Notify Success'
        uses: 8398a7/action-slack@v3
        with:
          status: 'success'
          channel: '#production'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,commit,author,action,eventName,ref,workflow
          custom_payload: |
            {
              "text": "🎉 PSA Grading App deployed to production!",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Production Deployment Successful* 🎉\n\n*App:* PSA Grading\n*Environment:* Production\n*Commit:* ${{ github.sha }}\n*Author:* ${{ github.actor }}\n*URL:* https://${{ secrets.DOMAIN }}"
                  }
                }
              ]
            }

  # ===============================================
  # 🚨 ROLLBACK EN CAS D'ÉCHEC
  # ===============================================
  rollback:
    name: '🚨 Emergency Rollback'
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: |
      always() && 
      (needs.deploy-staging.result == 'failure' || needs.deploy-production.result == 'failure')
      
    environment:
      name: ${{ needs.analyze.outputs.environment }}
      
    steps:
      - name: '🚨 Execute Rollback'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ needs.analyze.outputs.environment == 'production' && secrets.PRODUCTION_HOST || secrets.STAGING_HOST }}
          username: ${{ needs.analyze.outputs.environment == 'production' && secrets.PRODUCTION_USER || secrets.STAGING_USER }}
          key: ${{ needs.analyze.outputs.environment == 'production' && secrets.PRODUCTION_SSH_KEY || secrets.STAGING_SSH_KEY }}
          port: ${{ needs.analyze.outputs.environment == 'production' && secrets.PRODUCTION_PORT || secrets.STAGING_PORT || 22 }}
          script: |
            set -e
            
            echo "🚨 INITIATING EMERGENCY ROLLBACK"
            
            export APP_DIR="/var/www/psa-grading-app"
            export ENV="${{ needs.analyze.outputs.environment }}"
            export COMPOSE_FILE="$APP_DIR/docker-compose.$ENV.yml"
            
            cd $APP_DIR
            
            # Rollback à la version précédente
            if [ -f "docker-compose.$ENV.yml.backup" ]; then
              mv docker-compose.$ENV.yml.backup docker-compose.$ENV.yml
            fi
            
            # Restaurer dernière image stable
            docker-compose -f $COMPOSE_FILE down
            docker-compose -f $COMPOSE_FILE up -d
            
            # Vérification rollback
            sleep 60
            for i in {1..5}; do
              if curl -f -s "http://localhost:5000/healthz" > /dev/null; then
                echo "✅ Rollback successful!"
                break
              fi
              sleep 30
            done
            
      - name: '📧 Notify Rollback'
        uses: 8398a7/action-slack@v3
        with:
          status: 'failure'
          channel: '#alerts'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          custom_payload: |
            {
              "text": "🚨 EMERGENCY ROLLBACK EXECUTED",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*EMERGENCY ROLLBACK* 🚨\n\n*App:* PSA Grading\n*Environment:* ${{ needs.analyze.outputs.environment }}\n*Reason:* Deployment failure\n*Commit:* ${{ github.sha }}\n*Action:* Rollback to previous stable version"
                  }
                }
              ]
            }

# ===============================================
# 🧹 CLEANUP ET MAINTENANCE
# ===============================================
  cleanup:
    name: '🧹 Cleanup & Maintenance'
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always()
    
    steps:
      - name: '🧹 Cleanup Old Images'
        run: |
          echo "🧹 Cleaning up old Docker images..."
          # Les images sont nettoyées automatiquement sur les serveurs
          
      - name: '📊 Update Deployment Status'
        uses: actions/github-script@v7
        with:
          script: |
            const deploymentStatus = '${{ needs.deploy-production.result }}' === 'success' ? 'success' : 'failure';
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: context.payload.deployment?.id || 0,
              state: deploymentStatus,
              description: `Deployment ${deploymentStatus}`,
              environment_url: 'https://${{ secrets.DOMAIN }}'
            });