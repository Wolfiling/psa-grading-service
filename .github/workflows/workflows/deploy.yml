# ===============================================
# GITHUB ACTIONS - PSA GRADING APP DEPLOYMENT
# ===============================================
# ðŸš€ Pipeline CI/CD complet avec Docker et dÃ©ploiement automatisÃ©
# ðŸ”’ Gestion sÃ©curisÃ©e des secrets GitHub
# ðŸ“Š Tests, build, dÃ©ploiement, rollback automatique

name: 'ðŸš€ PSA Grading App - Deploy'

on:
  push:
    branches: [ main, develop ]
    paths-ignore:
      - '*.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      skip_tests:
        description: 'Skip tests'
        required: false
        default: false
        type: boolean

# ===============================================
# VARIABLES GLOBALES
# ===============================================
env:
  # Configuration Docker
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  
  # Configuration Node.js
  NODE_VERSION: '18'
  
  # Configuration dÃ©ploiement
  DEPLOYMENT_TIMEOUT: 900  # 15 minutes
  HEALTH_CHECK_RETRIES: 10
  HEALTH_CHECK_INTERVAL: 30

# ===============================================
# JOBS PIPELINE
# ===============================================
jobs:
  # ===============================================
  # ðŸ” ANALYSE ET VALIDATION
  # ===============================================
  analyze:
    name: 'ðŸ” Code Analysis & Security'
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event_name == 'push'
    
    outputs:
      should-deploy: ${{ steps.changes.outputs.should-deploy }}
      environment: ${{ steps.env-detection.outputs.environment }}
      
    steps:
      - name: 'ðŸ“¥ Checkout Code'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: 'ðŸ” Detect Changes'
        id: changes
        run: |
          # VÃ©rifier si des fichiers critiques ont changÃ©
          if git diff --name-only ${{ github.event.before }}..${{ github.sha }} | grep -E "(server/|client/|package\.json|Dockerfile)" > /dev/null; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          fi
          
      - name: 'ðŸŽ¯ Environment Detection'
        id: env-detection
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
          else
            echo "environment=review" >> $GITHUB_OUTPUT
          fi
          
      - name: 'ðŸ”’ Security Scan - CodeQL'
        if: github.event_name == 'pull_request'
        uses: github/codeql-action/init@v3
        with:
          languages: javascript
          
      - name: 'ðŸ”’ Security Scan - Trivy'
        if: steps.changes.outputs.should-deploy == 'true'
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          
      - name: 'ðŸ“¤ Upload Security Results'
        if: steps.changes.outputs.should-deploy == 'true'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'

  # ===============================================
  # ðŸ§ª TESTS ET VALIDATION
  # ===============================================
  test:
    name: 'ðŸ§ª Tests & Quality'
    runs-on: ubuntu-latest
    needs: analyze
    if: needs.analyze.outputs.should-deploy == 'true' && !github.event.inputs.skip_tests
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_USER: test_user
          POSTGRES_DB: psa_grading_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    strategy:
      matrix:
        node-version: ['18', '20']
        
    steps:
      - name: 'ðŸ“¥ Checkout Code'
        uses: actions/checkout@v4
        
      - name: 'ðŸŸ¢ Setup Node.js ${{ matrix.node-version }}'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
          
      - name: 'ðŸ“¦ Install Dependencies'
        run: |
          npm ci --prefer-offline --no-audit
          
      - name: 'ðŸ”§ Setup Test Environment'
        run: |
          cp .env.github.template .env.test
          echo "DATABASE_URL=postgresql://test_user:test_password@localhost:5432/psa_grading_test" >> .env.test
          echo "NODE_ENV=test" >> .env.test
          
      - name: 'ðŸ—ƒï¸ Database Setup'
        run: |
          NODE_ENV=test npm run db:migrate || true
          
      - name: 'ðŸ§ª Run Tests'
        run: |
          npm run test:coverage
        env:
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/psa_grading_test
          NODE_ENV: test
          
      - name: 'ðŸ” ESLint Check'
        run: |
          npx eslint . --ext .js,.jsx --max-warnings 0 || true
          
      - name: 'ðŸ›¡ï¸ Security Validation'
        run: |
          npm run security:validate || true
          
      - name: 'ðŸ“Š Upload Coverage'
        if: matrix.node-version == '18'
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
          fail_ci_if_error: false

  # ===============================================
  # ðŸ³ BUILD DOCKER IMAGE
  # ===============================================
  build:
    name: 'ðŸ³ Docker Build & Push'
    runs-on: ubuntu-latest
    needs: [analyze, test]
    if: |
      always() && 
      needs.analyze.outputs.should-deploy == 'true' && 
      (needs.test.result == 'success' || needs.test.result == 'skipped')
      
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      
    steps:
      - name: 'ðŸ“¥ Checkout Code'
        uses: actions/checkout@v4
        
      - name: 'ðŸ³ Setup Docker Buildx'
        uses: docker/setup-buildx-action@v3
        
      - name: 'ðŸ” Login to Container Registry'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: 'ðŸ·ï¸ Extract Metadata'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            
      - name: 'ðŸ”¨ Build and Push Image'
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
            
      - name: 'ðŸ” Scan Docker Image'
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.meta.outputs.tags }}
          format: 'sarif'
          output: 'docker-trivy-results.sarif'
          
      - name: 'ðŸ“¤ Upload Docker Scan Results'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'docker-trivy-results.sarif'

  # ===============================================
  # ðŸš€ DÃ‰PLOIEMENT STAGING
  # ===============================================
  deploy-staging:
    name: 'ðŸš€ Deploy to Staging'
    runs-on: ubuntu-latest
    needs: [analyze, test, build]
    if: |
      always() && 
      needs.analyze.outputs.environment == 'staging' &&
      needs.build.result == 'success'
      
    environment:
      name: staging
      url: https://staging.${{ secrets.DOMAIN }}
      
    steps:
      - name: 'ðŸ“¥ Checkout Code'
        uses: actions/checkout@v4
        
      - name: 'ðŸ”§ Setup Deployment Environment'
        run: |
          echo "DEPLOYMENT_ENV=staging" >> $GITHUB_ENV
          echo "DOCKER_IMAGE=${{ needs.build.outputs.image-tag }}" >> $GITHUB_ENV
          
      - name: 'ðŸš€ Deploy to Staging Server'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          port: ${{ secrets.STAGING_PORT || 22 }}
          timeout: ${{ env.DEPLOYMENT_TIMEOUT }}
          script: |
            set -e
            
            # Variables
            export DOCKER_IMAGE="${{ needs.build.outputs.image-tag }}"
            export DEPLOYMENT_ENV="staging"
            export APP_DIR="/var/www/psa-grading-app"
            export COMPOSE_FILE="$APP_DIR/docker-compose.staging.yml"
            
            # Navigation
            cd $APP_DIR
            
            # Backup avant dÃ©ploiement
            docker-compose -f $COMPOSE_FILE exec -T postgres pg_dump -U postgres psa_grading > backup-staging-$(date +%Y%m%d-%H%M%S).sql || true
            
            # Pull nouvelle image
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            docker pull $DOCKER_IMAGE
            
            # Mise Ã  jour configuration
            export DATABASE_URL="${{ secrets.STAGING_DATABASE_URL }}"
            export BREVO_API_KEY="${{ secrets.BREVO_API_KEY }}"
            export PSA_EMAIL="${{ secrets.PSA_EMAIL }}"
            export PSA_PASSWORD="${{ secrets.PSA_PASSWORD }}"
            export ADMIN_PASSWORD="${{ secrets.STAGING_ADMIN_PASSWORD }}"
            export SESSION_SECRET="${{ secrets.SESSION_SECRET }}"
            export PSA_SECRET="${{ secrets.PSA_SECRET }}"
            export JWT_SECRET="${{ secrets.JWT_SECRET }}"
            export PSA_CLIENT_SECRET="${{ secrets.PSA_CLIENT_SECRET }}"
            
            # DÃ©ploiement sans downtime
            docker-compose -f $COMPOSE_FILE up -d --remove-orphans
            
            # Health check
            for i in {1..10}; do
              if curl -f -s "http://localhost:5000/healthz" > /dev/null; then
                echo "âœ… Staging deployment successful!"
                break
              fi
              echo "â³ Waiting for application (attempt $i/10)..."
              sleep 30
            done
            
      - name: 'ðŸ” Post-deployment Tests'
        run: |
          # Tests post-dÃ©ploiement
          sleep 60
          curl -f "https://staging.${{ secrets.DOMAIN }}/healthz" || exit 1
          echo "âœ… Staging health check passed"
          
      - name: 'ðŸ“§ Notify Deployment'
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,commit,author,action,eventName,ref,workflow

  # ===============================================
  # ðŸ­ DÃ‰PLOIEMENT PRODUCTION  
  # ===============================================
  deploy-production:
    name: 'ðŸ­ Deploy to Production'
    runs-on: ubuntu-latest
    needs: [analyze, test, build]
    if: |
      always() && 
      needs.analyze.outputs.environment == 'production' &&
      needs.build.result == 'success'
      
    environment:
      name: production
      url: https://${{ secrets.DOMAIN }}
      
    steps:
      - name: 'ðŸ“¥ Checkout Code'
        uses: actions/checkout@v4
        
      - name: 'â¸ï¸ Manual Approval Required'
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ secrets.GITHUB_TOKEN }}
          approvers: ${{ secrets.PRODUCTION_APPROVERS }}
          minimum-approvals: 2
          issue-title: "ðŸ­ Production Deployment Approval - ${{ github.sha }}"
          issue-body: |
            **Production deployment requires approval**
            
            **Changes:**
            - Commit: ${{ github.sha }}
            - Author: ${{ github.actor }}
            - Branch: ${{ github.ref }}
            
            **Docker Image:**
            - Image: ${{ needs.build.outputs.image-tag }}
            - Digest: ${{ needs.build.outputs.image-digest }}
            
            **Pre-deployment Checklist:**
            - [ ] All tests passed
            - [ ] Security scans completed
            - [ ] Staging deployment successful
            - [ ] Database migrations reviewed
            - [ ] Rollback plan confirmed
            
            Please review and approve this deployment.
            
      - name: 'ðŸ’¾ Create Production Backup'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          port: ${{ secrets.PRODUCTION_PORT || 22 }}
          timeout: 300
          script: |
            set -e
            
            # Backup complet avant dÃ©ploiement
            export BACKUP_DIR="/var/backups/psa-grading"
            export TIMESTAMP=$(date +%Y%m%d-%H%M%S)
            
            mkdir -p $BACKUP_DIR
            
            # Backup base de donnÃ©es
            docker exec psa-postgres pg_dump -U postgres psa_grading > $BACKUP_DIR/db-backup-$TIMESTAMP.sql
            
            # Backup application
            tar -czf $BACKUP_DIR/app-backup-$TIMESTAMP.tar.gz -C /var/www psa-grading-app
            
            # Backup configuration
            cp /var/www/psa-grading-app/.env $BACKUP_DIR/env-backup-$TIMESTAMP
            
            echo "âœ… Backup completed: $BACKUP_DIR/backup-$TIMESTAMP"
            
      - name: 'ðŸš€ Deploy to Production'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          port: ${{ secrets.PRODUCTION_PORT || 22 }}
          timeout: ${{ env.DEPLOYMENT_TIMEOUT }}
          script: |
            set -e
            
            # Variables production
            export DOCKER_IMAGE="${{ needs.build.outputs.image-tag }}"
            export DEPLOYMENT_ENV="production"
            export APP_DIR="/var/www/psa-grading-app"
            export COMPOSE_FILE="$APP_DIR/docker-compose.production.yml"
            
            cd $APP_DIR
            
            # Login Docker
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Pull nouvelle image
            docker pull $DOCKER_IMAGE
            
            # Configuration production
            export DATABASE_URL="${{ secrets.PRODUCTION_DATABASE_URL }}"
            export BREVO_API_KEY="${{ secrets.BREVO_API_KEY }}"
            export PSA_EMAIL="${{ secrets.PSA_EMAIL }}"
            export PSA_PASSWORD="${{ secrets.PSA_PASSWORD }}"
            export ADMIN_PASSWORD="${{ secrets.PRODUCTION_ADMIN_PASSWORD }}"
            export SESSION_SECRET="${{ secrets.SESSION_SECRET }}"
            export PSA_SECRET="${{ secrets.PSA_SECRET }}"
            export JWT_SECRET="${{ secrets.JWT_SECRET }}"
            export PSA_CLIENT_SECRET="${{ secrets.PSA_CLIENT_SECRET }}"
            export ALLOWED_ORIGINS="https://${{ secrets.DOMAIN }}"
            export PUBLIC_URL="https://${{ secrets.DOMAIN }}"
            
            # DÃ©ploiement blue-green
            docker-compose -f $COMPOSE_FILE up -d --remove-orphans --scale app=2
            
            # Attente stabilisation
            sleep 60
            
            # Health check approfondi
            for i in {1..${{ env.HEALTH_CHECK_RETRIES }}}; do
              if curl -f -s "http://localhost:5000/healthz" > /dev/null; then
                echo "âœ… Production health check passed (attempt $i)"
                break
              fi
              echo "â³ Production health check (attempt $i/${{ env.HEALTH_CHECK_RETRIES }})..."
              sleep ${{ env.HEALTH_CHECK_INTERVAL }}
              
              if [ $i -eq ${{ env.HEALTH_CHECK_RETRIES }} ]; then
                echo "âŒ Production health check failed - initiating rollback"
                exit 1
              fi
            done
            
            # Validation fonctionnelle
            curl -f "https://${{ secrets.DOMAIN }}/healthz" || exit 1
            
            # Nettoyage anciennes images
            docker image prune -f --filter "until=24h"
            
      - name: 'âœ… Production Deployment Success'
        run: |
          echo "ðŸŽ‰ Production deployment completed successfully!"
          echo "ðŸŒ Application URL: https://${{ secrets.DOMAIN }}"
          echo "ðŸ“Š Commit: ${{ github.sha }}"
          echo "ðŸ³ Image: ${{ needs.build.outputs.image-tag }}"
          
      - name: 'ðŸ“§ Notify Success'
        uses: 8398a7/action-slack@v3
        with:
          status: 'success'
          channel: '#production'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,commit,author,action,eventName,ref,workflow
          custom_payload: |
            {
              "text": "ðŸŽ‰ PSA Grading App deployed to production!",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Production Deployment Successful* ðŸŽ‰\n\n*App:* PSA Grading\n*Environment:* Production\n*Commit:* ${{ github.sha }}\n*Author:* ${{ github.actor }}\n*URL:* https://${{ secrets.DOMAIN }}"
                  }
                }
              ]
            }

  # ===============================================
  # ðŸš¨ ROLLBACK EN CAS D'Ã‰CHEC
  # ===============================================
  rollback:
    name: 'ðŸš¨ Emergency Rollback'
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: |
      always() && 
      (needs.deploy-staging.result == 'failure' || needs.deploy-production.result == 'failure')
      
    environment:
      name: ${{ needs.analyze.outputs.environment }}
      
    steps:
      - name: 'ðŸš¨ Execute Rollback'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ needs.analyze.outputs.environment == 'production' && secrets.PRODUCTION_HOST || secrets.STAGING_HOST }}
          username: ${{ needs.analyze.outputs.environment == 'production' && secrets.PRODUCTION_USER || secrets.STAGING_USER }}
          key: ${{ needs.analyze.outputs.environment == 'production' && secrets.PRODUCTION_SSH_KEY || secrets.STAGING_SSH_KEY }}
          port: ${{ needs.analyze.outputs.environment == 'production' && secrets.PRODUCTION_PORT || secrets.STAGING_PORT || 22 }}
          script: |
            set -e
            
            echo "ðŸš¨ INITIATING EMERGENCY ROLLBACK"
            
            export APP_DIR="/var/www/psa-grading-app"
            export ENV="${{ needs.analyze.outputs.environment }}"
            export COMPOSE_FILE="$APP_DIR/docker-compose.$ENV.yml"
            
            cd $APP_DIR
            
            # Rollback Ã  la version prÃ©cÃ©dente
            if [ -f "docker-compose.$ENV.yml.backup" ]; then
              mv docker-compose.$ENV.yml.backup docker-compose.$ENV.yml
            fi
            
            # Restaurer derniÃ¨re image stable
            docker-compose -f $COMPOSE_FILE down
            docker-compose -f $COMPOSE_FILE up -d
            
            # VÃ©rification rollback
            sleep 60
            for i in {1..5}; do
              if curl -f -s "http://localhost:5000/healthz" > /dev/null; then
                echo "âœ… Rollback successful!"
                break
              fi
              sleep 30
            done
            
      - name: 'ðŸ“§ Notify Rollback'
        uses: 8398a7/action-slack@v3
        with:
          status: 'failure'
          channel: '#alerts'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          custom_payload: |
            {
              "text": "ðŸš¨ EMERGENCY ROLLBACK EXECUTED",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*EMERGENCY ROLLBACK* ðŸš¨\n\n*App:* PSA Grading\n*Environment:* ${{ needs.analyze.outputs.environment }}\n*Reason:* Deployment failure\n*Commit:* ${{ github.sha }}\n*Action:* Rollback to previous stable version"
                  }
                }
              ]
            }

# ===============================================
# ðŸ§¹ CLEANUP ET MAINTENANCE
# ===============================================
  cleanup:
    name: 'ðŸ§¹ Cleanup & Maintenance'
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always()
    
    steps:
      - name: 'ðŸ§¹ Cleanup Old Images'
        run: |
          echo "ðŸ§¹ Cleaning up old Docker images..."
          # Les images sont nettoyÃ©es automatiquement sur les serveurs
          
      - name: 'ðŸ“Š Update Deployment Status'
        uses: actions/github-script@v7
        with:
          script: |
            const deploymentStatus = '${{ needs.deploy-production.result }}' === 'success' ? 'success' : 'failure';
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: context.payload.deployment?.id || 0,
              state: deploymentStatus,
              description: `Deployment ${deploymentStatus}`,
              environment_url: 'https://${{ secrets.DOMAIN }}'
            });